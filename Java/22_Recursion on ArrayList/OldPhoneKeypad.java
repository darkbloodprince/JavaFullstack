/*Old Phone Keypad
You are given an old phone with a keypad. Each key on the keypad has multiple letters assigned to it, which can be used to type messages.

These are the letters present on each key:

 [A,B,C]    [D,E,F]    [G,H,I]
   1         2         3

 [J,K,L]    [M,N,O]    [P,Q,R,S]  
   4         5          6

  [T,U]     [V,W,X]      [Y,Z]
    7         8          9

    [ ]       [ ]         [ ]
    *        0          #  

You are also provided with an integer array consisting of all the numbers that are pressed, in the same order. Each number can be pressed multiple times even if its mentioned only one time.

Explanation:

If 3 is given in the array this means corresponding letter can be [G,H,I]
Your task is to return the list of strings that can be generated by pressing the keys in the array by writing a recursive code.

NOTE: The buttons are pressed in given order i.e. first button at '0-th' index is pressed and then '1-st' and so on. The output should be in lexicographic order with only uppercase letters.

Input Format
First line contains the number of keys n pressed on the phone

Second line contains n space seprated integers that are pressed on the phone.

Output Format
Return a list of strings consisting of all the strings that can be generated by pressing those keys the the phone.

Example 1
Input

2
2 5
Output

DM DN DO EM EN EO FM FN FO
Explanation

When we press 2,5 then
[DM,DN,DO,EM,EN,EO,FM,FN,FO] is the list of possible words.

Example 2
Input

2
6 7
Output

PT PU QT QU RT RU ST SU 
Explanation

When we press 6,7 then
[PT,PU,QT,QU,RT,RU,ST,SU] is the list of possible words.

Constraints
1 <= n <= 10
1 <= key[i] <= 9
#Approach

It can be observed that each digit can represent 3 to 4 different alphabets (apart from 0). So the idea is to form a recursive function. Then map the number with its string of probable alphabets, i.e 1 with "ABC", 2 with "DEF" etc. Now the recursive function will try all the alphabets, mapped to the current digit in alphabetic order, and again call the recursive function for the next digit and will pass on the current output string.

Algorithm:

Map the number with its string of probable alphabets, i.e 1 with "ABC", 2 with "DEF" etc.
Create a recursive function which takes the following parameters, output string, number array, current index, and length of number array
If the current index is equal to the length of the number array then print the output string.
Extract the string at digit[current_index] from the Map, where the digit is the input number array.
Run a loop to traverse the string from start to end
For every index again call the recursive function with the output string concatenated with the ith character of the string and the current_index + 1.
Time Complexity : O(4^n) where n is a number of digits in the input number. Each digit of a number has 3 or 4 alphabets, so it can be said that each digit has 4 alphabets as options. If there are n digits then there are 4 options for the first digit and for each alphabet of the first digit there are 4 options in the second digit, i.e for every recursion 4 more recursions are called (if it does not match the base case). So the time complexity is O(4n).

Space Complexity : O(1) No extra space is used

Below is the implimentation of above Approach

1. JAVA*/
import java.util.*;

class OldPhoneKeypad {

    // A 2D array (10x5) to map each number key (0â€“9) to corresponding characters
    static Character[][] numberToCharMap;

    // This function initializes the numberToCharMap
    private static void generateNumberToCharMap() {
        numberToCharMap = new Character[10][5]; // Each key can map to up to 5 letters (for safety)
        
        // Assigning letters to each key (custom mapping used here)
        numberToCharMap[0] = new Character[]{'\0'};                // Key 0 -> no letters
        numberToCharMap[1] = new Character[]{'A','B','C'};         // Key 1 -> A, B, C
        numberToCharMap[2] = new Character[]{'D','E','F'};         // Key 2 -> D, E, F
        numberToCharMap[3] = new Character[]{'G','H','I'};         // Key 3 -> G, H, I
        numberToCharMap[4] = new Character[]{'J','K','L'};         // Key 4 -> J, K, L
        numberToCharMap[5] = new Character[]{'M','N','O'};         // Key 5 -> M, N, O
        numberToCharMap[6] = new Character[]{'P','Q','R','S'};     // Key 6 -> P, Q, R, S
        numberToCharMap[7] = new Character[]{'T','U'};             // Key 7 -> T, U
        numberToCharMap[8] = new Character[]{'V','W','X'};         // Key 8 -> V, W, X
        numberToCharMap[9] = new Character[]{'Y','Z'};             // Key 9 -> Y, Z
    }

    /**
     * Recursive function that generates all possible letter combinations
     * for the given sequence of numbers.
     *
     * @param numbers  The array of digits (like keys pressed)
     * @param len      The total number of digits
     * @param numIndex The current index we are processing
     * @param s        The current combination string being built
     * @return         List of all possible strings for given number sequence
     */
    private static ArrayList<String> generateWords(int[] numbers, int len, int numIndex, String s) {

        // Base case: if we have processed all digits, return the formed string
        if (len == numIndex)
            return new ArrayList<>(Collections.singleton(s));  // Return a list with current string
        
        // List to store all combinations from this recursion level
        ArrayList<String> stringList = new ArrayList<>();

        // Loop through all characters mapped to the current digit
        for (int i = 0; i < numberToCharMap[numbers[numIndex]].length; i++) {
            
            // Copy the current partial string (to avoid modifying original 's')
            String sCopy = String.copyValueOf(s.toCharArray());
            
            // Append the current character for this digit
            sCopy = sCopy.concat(numberToCharMap[numbers[numIndex]][i].toString());
            
            // Recursively generate combinations for next digits
            stringList.addAll(generateWords(numbers, len, numIndex + 1, sCopy));
        }

        // Return all generated strings for this recursion level
        return stringList;
    }

    /**
     * Main function that starts the process of generating words
     * from the given number sequence.
     */
    static ArrayList<String> OldPhone(int n, int[] keys) {
        // Step 1: Initialize the number-to-character mapping
        generateNumberToCharMap();

        // Step 2: Start recursion from the 0th index with an empty string
        return generateWords(keys, n, 0, "");
    }
	
	public static void main(String[] args) throws Throwable {
        Scanner sc = new Scanner(System.in);

        // Read the number of digits (like length of number sequence)
        int n = sc.nextInt();

        // Read the sequence of digits
        int[] keys = new int[n];
        for (int i = 0; i < n; ++i) {
            keys[i] = sc.nextInt();
        }

        // Generate all possible letter combinations
        ArrayList<String> ans = OldPhone(n, keys);

        // Print all generated combinations
        for (String i : ans)
            System.out.print(i + " ");
    }
}
